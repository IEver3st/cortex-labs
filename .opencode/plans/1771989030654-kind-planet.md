# Auto-Generate UV Templates from Imported YFT Files

## Summary

When a `.yft` file is imported, automatically generate a 4096x4096 UV template PNG with color-coded mesh parts. The template shows the 2D texture layout of the vehicle's exterior paintable surfaces, ready for artists to use as a livery painting guide.

---

## Approach: Canvas2D UV Rasterization (Frontend)

**Why this approach:** The codebase already uses Canvas2D extensively for PSD layer compositing (`psd-layers.js`), texture generation, and PNG export via `writeFile`. No new dependencies needed. The parsed `drawable` object from `parseYft()` already contains all UV coordinates and triangle indices we need.

**Rejected alternatives:**
- **WebGL/Three.js rendering**: Overkill for 2D triangle rasterization; would require custom shaders and render target management for a fundamentally 2D operation.
- **Rust backend**: Would duplicate mesh parsing logic already in JS; adds IPC overhead for passing large mesh data back and forth.

---

## Implementation Plan

### New Files

| File | Purpose |
|---|---|
| `src/lib/uv-template.js` | Core UV template generation logic |

### Modified Files

| File | Change |
|---|---|
| `src/components/Viewer.jsx` | Hook into YFT parse flow to trigger template generation |
| `src/App.jsx` | Add state/UI for template generation status + notification |
| `src/index.css` | Add CSS for template notification toast |

---

### Step 1: Create `src/lib/uv-template.js`

This module handles all UV template generation logic.

#### Color-Coding Scheme

Assign distinct colors to mesh material categories based on existing shader name classification:

```js
const MATERIAL_COLORS = {
  paint:     { fill: "rgba(59, 186, 163, 0.35)", stroke: "#3dbaa3" },  // teal (primary accent)
  glass:     { fill: "rgba(100, 149, 237, 0.30)", stroke: "#6495ed" }, // cornflower blue
  chrome:    { fill: "rgba(192, 192, 210, 0.30)", stroke: "#c0c0d2" }, // silver
  tire:      { fill: "rgba(90, 90, 90, 0.35)",    stroke: "#5a5a5a" }, // dark gray
  interior:  { fill: "rgba(180, 120, 60, 0.30)",  stroke: "#b4783c" }, // amber
  lights:    { fill: "rgba(255, 220, 80, 0.30)",  stroke: "#ffdc50" }, // yellow
  decal:     { fill: "rgba(220, 100, 220, 0.30)", stroke: "#dc64dc" }, // magenta
  badge:     { fill: "rgba(255, 165, 0, 0.30)",   stroke: "#ffa500" }, // orange
  default:   { fill: "rgba(150, 150, 170, 0.25)", stroke: "#9696aa" }, // neutral gray
};
```

Material type detection reuses the same naming conventions already in `viewer-utils.js` (`buildDrawableObject`):
- `vehicle_paint*`, `carpaint` → paint
- `vehglass`, `glass` → glass
- Mesh names containing `tire`, `wheel` → tire
- `interior`, `seat`, `dash` → interior
- `vehicle_lights` → lights
- `vehicle_decal`, `decal` → decal
- `vehicle_badges`, `badge` → badge
- Everything else → default

#### Core Functions

```js
/**
 * Classify a material/mesh name into a category for color-coding.
 * @param {string} materialName - shader/material name from the drawable
 * @returns {string} category key from MATERIAL_COLORS
 */
function classifyMaterial(materialName) { ... }

/**
 * Rasterize a single triangle onto a canvas context.
 * Uses canvas Path2D for filled triangles + stroke wireframe.
 * @param {CanvasRenderingContext2D} ctx
 * @param {Float32Array} uvs - interleaved [u,v,...] array
 * @param {Uint32Array} indices - triangle index array
 * @param {number} triIndex - which triangle (0-based)
 * @param {number} size - canvas dimension (4096)
 * @param {{ fill: string, stroke: string }} colors
 */
function rasterizeTriangle(ctx, uvs, indices, triIndex, size, colors) { ... }

/**
 * Generate a UV template image from a parsed YFT drawable.
 * @param {object} drawable - output from parseYft()
 * @param {object} options
 * @param {number} options.size - image dimension (default 4096)
 * @param {boolean} options.exteriorOnly - filter to exterior parts only (default true)
 * @returns {{ canvas: HTMLCanvasElement, legend: Array<{name: string, color: string}> }}
 */
export function generateUVTemplate(drawable, options = {}) { ... }

/**
 * Export the UV template canvas to a PNG Uint8Array.
 * @param {HTMLCanvasElement} canvas
 * @returns {Promise<Uint8Array>}
 */
export async function canvasToUint8Array(canvas) { ... }
```

#### `generateUVTemplate` Algorithm

1. Create a `4096x4096` canvas with transparent background
2. Draw a subtle dark background (`rgba(10, 12, 16, 0.95)`) to match the app aesthetic
3. Iterate over `drawable.models[*].meshes[*]`:
   - For each mesh, classify material via `classifyMaterial(mesh.materialName)`
   - Optionally filter meshes using exterior include/exclude tokens (reuse the same token lists from `Viewer.jsx`)
   - For each triangle (from `mesh.indices`, stride 3):
     - Read UV coords for the 3 vertices from `mesh.uvs`
     - Scale UVs to canvas coordinates: `x = u * size`, `y = v * size` (v is already flipped in parser)
     - Fill the triangle with the category's fill color
     - Stroke the triangle edges with the category's stroke color (0.5px line width for wireframe)
4. Draw a color legend in the bottom-right corner showing material type → color mapping (only for categories actually present in the model)
5. Draw model name label in top-left corner
6. Return `{ canvas, legend }`

#### Edge Cases

- **No UVs**: If `mesh.uvs` is null/empty, skip that mesh. If ALL meshes lack UVs, return null and show a warning notification.
- **UVs outside 0-1 range**: Clamp or wrap (modulo 1) UV coordinates to stay within canvas bounds. GTA V models sometimes tile.
- **Very dense meshes**: Canvas2D handles this fine — 4096x4096 is standard for GPU operations. May take 1-2 seconds for complex models; run in a `requestIdleCallback` or `setTimeout(0)` to avoid blocking UI.
- **YDD files**: Also supported — same `parseYft()` call with `YDD_SCAN_SETTINGS`, same drawable format.

---

### Step 2: Hook into Viewer.jsx YFT Parse Flow

**Integration point**: `Viewer.jsx` line ~806 — right after `parseYft()` succeeds and `drawable` is available, before `buildDrawableObject()`.

Add a new callback prop `onDrawableParsed` to the Viewer component. After a successful parse of a YFT/YDD:

```js
// ~line 817, after buildDrawableObject succeeds
if (drawable && onDrawableParsedRef.current) {
  onDrawableParsedRef.current(drawable, modelPath);
}
```

This keeps template generation decoupled from the viewer — the Viewer just emits the raw drawable data, and the parent (App.jsx) decides what to do with it.

---

### Step 3: Wire Up in App.jsx

In App.jsx:

1. **Add state**:
   - `templateGenerating` (boolean) — shows a subtle progress indicator
   - `templatePath` (string) — path of last generated template
   - `templateNotification` (object|null) — `{ message, type }` for toast display

2. **Add `handleDrawableParsed` callback**:
   ```js
   const handleDrawableParsed = useCallback(async (drawable, modelPath) => {
     if (!isTauriRuntime) return;
     setTemplateGenerating(true);
     try {
       const result = generateUVTemplate(drawable, { size: 4096, exteriorOnly: true });
       if (!result) {
         // No UV data available
         setTemplateNotification({ message: "No UV data found — template skipped", type: "warn" });
         return;
       }
       const bytes = await canvasToUint8Array(result.canvas);
       // Save next to the YFT file: {modelDir}/{modelName}_uv_template.png
       const dir = modelPath.replace(/[\\/][^\\/]+$/, "");
       const name = modelPath.split(/[\\/]/).pop()?.replace(/\.[^.]+$/, "") || "model";
       const templatePath = `${dir}/${name}_uv_template.png`;
       await writeFile(templatePath, bytes);
       setTemplatePath(templatePath);
       setTemplateNotification({ message: `UV template saved: ${name}_uv_template.png`, type: "success" });
     } catch (err) {
       console.error("[UV Template]", err);
       setTemplateNotification({ message: "Template generation failed", type: "error" });
     } finally {
       setTemplateGenerating(false);
     }
   }, [isTauriRuntime]);
   ```

3. **Pass to Viewer**: `<Viewer ... onDrawableParsed={handleDrawableParsed} />`

4. **Toast notification**: Add a small, auto-dismissing notification near the bottom of the viewport showing template generation status. Animate with `motion/react` (`AnimatePresence` + slide up + fade). Auto-dismiss after 4 seconds.

---

### Step 4: Add CSS for Template Notification

In `src/index.css`, add styles for the `.cs-template-toast` component:
- Positioned fixed at bottom-center of viewport
- Uses `var(--mg-surface)` background with `var(--mg-border)` border
- `var(--font-hud)` text, uppercase, small
- Success state: teal accent (`var(--mg-primary)`), error: `var(--mg-destructive)`
- Subtle entry animation handled by Framer Motion

---

## Data Flow

```
User opens .yft file
  → App.jsx loadModel(path)
    → Viewer.jsx receives modelPath prop
      → readFile(modelPath)
      → parseYft(bytes, name) → drawable object
      → buildDrawableObject(drawable) → Three.js scene (existing flow)
      → onDrawableParsed(drawable, modelPath) → NEW callback
        → App.jsx handleDrawableParsed()
          → generateUVTemplate(drawable) → canvas
          → canvasToUint8Array(canvas) → PNG bytes
          → writeFile(templatePath, bytes) → saved to disk
          → Show success toast notification
```

---

## Verification

1. **Build check**: `bun run build` — must compile without errors
2. **Manual test with `bun tauri dev`**:
   - Load a vehicle `.yft` file (e.g., `adder_hi.yft`)
   - Verify a `{name}_uv_template.png` file appears next to the YFT
   - Open the PNG — should show color-coded UV layout at 4096x4096
   - Verify the legend shows correct material categories
   - Load a YFT without UVs (rare) — should show a warning toast, no crash
   - Load a `.ydd` file — should also generate a template
3. **Performance**: Template generation should complete within 2 seconds for complex vehicle models
