# Plan: Auto-generate downloadable template maps from imported `.yft`

## Confirmed scope (from user)
- v1 file types: `.yft` only.
- Generation timing: automatic on model import.
- Template content: target map only (no full hierarchy schema).
- Mesh data source: existing JS parser/render path (`parseYft` + `buildDrawableObject`).
- Output requirement: template must be downloadable.

## Recommended implementation

### 1) Generate template map in the existing Viewer import pipeline
**Files**
- `src/components/Viewer.jsx`
- `src/lib/template-map.js` (new utility module)

**Changes**
1. Add a small pure utility to build a deterministic template payload from a loaded model object plus inferred targets.
2. In `Viewer.jsx`, after existing target inference:
   - current inference hook is at `src/components/Viewer.jsx:924-933` (`collectTextureTargets`, `findLiveryTarget`, `findWindowTemplateTarget`, `onModelInfo`).
   - build template JSON only when `object.userData.sourceFormat === "yft"`.
3. Extend `onModelInfo` payload with `templateMap` and lightweight generation status metadata.

**Template schema (v1)**
```json
{
  "schema": "cortex.template-map.v1",
  "fileType": "yft",
  "source": {
    "fileName": "adder_hi.yft",
    "modelName": "adder_hi",
    "generatedAt": "ISO-8601"
  },
  "targets": {
    "material:vehicle_paint1": [
      {
        "meshName": "chassis",
        "materialName": "vehicle_paint1"
      }
    ],
    "mesh:sign_1": [
      {
        "meshName": "sign_1",
        "materialName": ""
      }
    ]
  },
  "inference": {
    "liveryTarget": "material:vehicle_paint1",
    "windowTarget": "material:vehglass"
  },
  "stats": {
    "targetCount": 2,
    "mappedMeshCount": 14
  }
}
```

### 2) Store generated template state in App and expose download action
**File**
- `src/App.jsx`

**Changes**
1. Add state for generated template payload + generation error status.
2. Update `handleModelInfo` (`src/App.jsx:583-602`) to consume `info.templateMap` and clear stale state when model changes/clears.
3. Reset generated template state in existing model reset paths (`src/App.jsx:417-445` and model unload handlers).
4. Add a `Download Template` action in the Model section (`src/App.jsx` around `1634-1651`) that appears/enables only when a `.yft` template map is available.
5. Implement download via `Blob` + `URL.createObjectURL` + temporary `<a download>` (same runtime-safe approach already used elsewhere in app for blob-based assets).
6. Use existing toast system (`showToast`) for success/failure feedback.

### 3) UI placement + dimension impact (critical)
**Primary placement**
- Add button in the Model panel block near existing Select/Change/Unload controls at `src/App.jsx:1634-1651`.

**Dimension controls and impact**
- Button baseline height comes from `CyberButton` base class `h-9` at `src/components/CyberUI.jsx:79`.
  - Increasing `h-9` -> taller controls across all Cyber buttons, larger vertical footprint.
  - Decreasing `h-9` -> denser controls, potential readability/click-target regression.
- Horizontal spacing for the row uses `className="flex gap-2"` at `src/App.jsx:1634`.
  - Increasing `gap-2` -> more separation, less space for labels.
  - Decreasing `gap-2` -> tighter layout, potential visual crowding.
- Panel width budget is governed by `--panel-width` at `src/index.css:31` and applied in `.cyber-panel` at `src/index.css:4964`.
  - Increasing width -> more room for controls/labels.
  - Decreasing width -> more truncation risk for long button labels.

## Edge cases and handling
- Non-`.yft` model imports: do not generate template map.
- Valid `.yft` but no inferred targets: still generate valid JSON with empty `targets`.
- Meshes without names/materials: normalize with safe fallback labels and omit missing optional fields.
- Re-import a different model: replace stale template state immediately.
- Download failure (environment/browser restrictions): show toast error, keep template in memory for retry.

## Files to modify
- `src/components/Viewer.jsx`
- `src/App.jsx`
- `src/lib/template-map.js` (new)

## Verification
1. Run `bun run build` and confirm successful compile.
2. Launch app, import a `.yft`, verify template generation occurs automatically (download button becomes available and no regressions in existing target inference).
3. Click `Download Template`, verify JSON file downloads with expected filename and schema fields.
4. Import non-`.yft` (`.dff`/`.clmesh`), verify download action is disabled/hidden and no errors are introduced.
5. Import multiple `.yft` files in sequence, verify downloaded payload updates per model (no stale template data).
